---
title: "Using ThermStats to calculate statistics for thermal images"
output:
  rmarkdown::html_vignette:
    toc: true
author: Rebecca A. Senior
date: "`r format(Sys.time(), '%d %B, %Y')`"
vignette: >
  %\VignetteIndexEntry{Using ThermStats to calculate statistics for thermal images}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
link-citations: yes
csl: elsevier-harvard.csl
biblio-style: apalike
bibliography: [refs.bib]
fontsize: 12pt
geometry: margin=2.5cm
mainfont: Calibri
lang: en-GB
papersize: a4
documentclass: article
header-includes:
- \usepackage{url}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhf{}
- \fancyfoot[CO,CE]{\thepage}
- \usepackage{setspace}
- \doublespacing
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
                      fig.align = "centre", fig.width = 16.6/2.54)
```

# Summary

`ThermStats` is designed for biologists using thermography to quantify thermal heteorgeneity. It uses the `Thermimage` package [@tattersall_thermimage:_2017] to batch process data from FLIR thermal cameras, and takes inspiration from FRAGSTATS [@fragstats_2012], `SDMTools` [@sdmtools_2014], @faye_toolbox_2016 and @shi_framework_2016 to facilitate the calculation of various metrics of thermal heterogeneity for any gridded temperature data.

The package is available to download from GitHub using `devtools`:

```{r install, echo = TRUE}
devtools::install_github("rasenior/ThermStats")
library(ThermStats)
```

Once loaded, the code below can be followed step-by-step.

# Extracting raw data

Data are extracted from FLIR images using `batch_extract`. This is a batch implementation of the `readflirJPG` function from `Thermimage`. It requires only the path to the directory of FLIR thermal images, and the freely available external software ['Exiftool'](https://www.sno.phy.queensu.ca/~phil/exiftool/ "Exiftool"). Besides raw data, this step also retrieves camera-specific calibration parameters which are required later to convert raw data to temperature values.

```{r batch-extract, echo= TRUE, results = "hide"}
# Batch extract thermal images included in ThermStats installation
flir_raw <-
    batch_extract(in_dir = system.file("extdata", 
                                       package = "ThermStats"),
                  write_results = FALSE)
```

# Converting raw data to temperature

Raw data are encoded in each thermal image as a 16 bit analog-to-digital signal, which represents the radiance received by the infrared sensor. The function `batch_convert` converts these raw data to temperature values using equations from infrared thermography, via a batch implementation of the function `raw2temp` in `Thermimage`. It uses the calibration constants extracted in `batch_extract` and environmental parameters defined by the user:

* Emissivity = the amount of radiation emmitted by a particular object, for a given temperature.
* Object distance = the distance between the camera and the object of interest.
* Reflected apparent temperature = the temperature resulting from radiation that originates from the atmosphere and is reflected by the object.
* Atmospheric temperature = the temperature of the atmosphere.
* Relative humidity = the relative humidity of the atmosphere.

```{r batch-convert, echo= TRUE, results = "hide"}
# Define raw data
raw_dat <- flir_raw$raw_dat
# Define camera calibration constants dataframe
camera_params <- flir_raw$camera_params
# Define metadata
metadata <- flir_metadata

# Create vector denoting the position of each photo within metadata
photo_index <- match(names(raw_dat), 
                     metadata$photo_no)

# Batch convert
flir_converted <-
    batch_convert(
        raw_dat = raw_dat,
        # Emissivity = mean of the range in Scheffers et al. 2017
        E = mean(c(0.982,0.99)),
        # Object distance = hypotenuse of a right triangle where the vertical side is 1.3 m 
        # (breast height) & the angle down is 45 degrees
        OD = (sqrt(2))*1.3,
        # Apparent reflected temperature, atmospheric temperature & infrared window temperature =
        # atmospheric temperature measured in the field
        RTemp = metadata$atm_temp[photo_index],
        ATemp = metadata$atm_temp[photo_index],
        IRWTemp = metadata$atm_temp[photo_index],
        # Infrared Window transmission = default value of 1
        IRT = 1,
        # Relative humidity = relative humidity measured in the field
        RH = metadata$rel_humidity[photo_index],
        # Calibration constants from 'batch_extract'
        PR1 = camera_params[,"PlanckR1"],
        PB = camera_params[,"PlanckB"],
        PF = camera_params[,"PlanckF"],
        PO = camera_params[,"PlanckO"],
        PR2 = camera_params[,"PlanckR2"],
        # Whether to write results or just return
        write_results = FALSE)
```

# Calculating thermal statistics

Statistics can be calculated for individual temperature matrices, or across multiple matrices within a specified grouping. The latter is useful for sampling designs where multiple images are collected at each sampling event to capture temperature across a wider sampling unit, such as a plot. In either case, statistics include summary statistics specified by the user -- for example, mean, minimum and maximum -- as well as spatial statistics for hot and cold spots, identified using the Getis-Ord local statistic [@getis_local_1996].

For an individual matrix, `get_stats` requires the user to specify the matrix and the desired statistics. Statistics can be calculated for geographic temperature data (in a matrix or raster format), in which case the user should also define the extent and projection of the data.

```{r get-stats, echo= TRUE, results = "hide"}
flir_stats <-
    get_stats(
        # The temperature matrix 
        val_mat = flir_converted$`8565`,
        # The ID of the matrix
        matrix_id = "8565",
        # Whether or not to identify hot and cold spots
        get_patches = TRUE,
        # The size of the neighourhood (for calculating local G stat)
        k = 8,
        # The neghbour weighting style (for calculating local G stat)
        style = "W",
        # The matrix projection (only relevant for geographic data)
        mat_proj = NULL,
        # The matrix extent (only relevant for geographic data)
        mat_extent = NULL,
        # The data to return
        return_vals = c(
            # Temperature data as dataframe
            "df", 
            # SpatialPolygonsDataFrame of patch outlines
            "patches", 
            # Patch statistics dataframe
            "pstats"),
        # The names of the statistics functions (to manually name columns in 'pstats')
        pixel_fns = NULL,
        # The summary statistics of interest
        median, perc_5, perc_95, SHDI
    )
```

For grouped matrices, `stats_by_group` requires the user to supply a list of matrices along with metadata and the name of the variable in the metadata that defines the matrix grouping. Table 1 shows the metadata used in the code snippet, where photo number ('photo_no') defines individual temperature matrices, and the replicate identity ('rep_id') defines the grouping of photos. There are two replicates, 'T7P1' and 'T7P2', and each has two associated photos.

```{r tab-B-1, results='asis'}
tab1 <- "
Table: Table 1: Example metadata denoting the grouping ('rep_id') of different temperature matrices. Statistics can be calculated over multiple matrices within a group, using the function `stats_by_group`.

| photo_no|rep_id | atm_temp| rel_humidity|
|--------:|:------|--------:|------------:|
|     8565|T7P1   |    24.00|           96|
|     8583|T7P1   |    24.00|           96|
|     8589|T7P2   |    23.25|           98|
|     8613|T7P2   |    23.50|           96|
"

cat(tab1) # output the table in a format good for HTML/PDF/docx conversion
```

```{r stats-by-group, results = "hide"}
flir_stats_group <-
    stats_by_group(
        # A dataframe denoting the grouping
        metadata = metadata,
        # List of temperature matrices
        mat_list = flir_converted,
        # Variable denoting the matrix IDs
        matrix_id = "photo_no",
        # Variable denoting the grouping
        grouping_var = "rep_id",
        # Desired precision of data
        round_val = 0.5,
        # The size of the neighourhood (for calculating local G stat)
        k = 8,
        # The neghbour weighting style (for calculating local G stat)
        style = "W",
        # The summary statistics of interest
        median, perc_5, perc_95, SHDI
    )
```

By default, both `get_stats` and `stats_by_group` return a dataframe with patch statistics (Table 2) for each matrix or matrix group, respectively. 

```{r tab-B-2, results='asis'}
tab2 <- "
Table: Table 2: A snippet of hot spot patch statistics returned by `stats_by_group`, which implements `get_stats` within groups.

| median| perc_5| perc_95|     SHDI| hot_shape_index| hot_aggregation|
|------:|------:|-------:|--------:|---------------:|---------------:|
|   23.5|     23|    24.5|     1.16|            7.54|           0.895|
|   24.0|     23|    25.0|     1.68|            7.80|           0.855|
"

cat(tab2) # output the table in a format good for HTML/PDF/docx conversion
```

<!-- # ```{r tab-B-2, tidy = FALSE, echo = FALSE} -->
<!-- # knitr::kable( -->
<!-- #     head(flir_stats_group[, c(1:5,8,13:17)], 10), booktabs = TRUE  -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->

# Plotting

In addition to patch statistics, `get_stats` can return (1) the temperature matrix in a dataframe format, and (2) a `SpatialPolygonsDataFrame` of its hot and cold spots. The function `plot_patches` can then recreate the original thermal image overlaid with outlines of hot and cold spots, as well as the temperature distribution (if `plot_distribution = TRUE`).

```{r fig-B-1, fig.cap= "The output of `plot_patches` includes a histogram and the original temperature data overlaid with outlines of hot and cold spots, identified using the Getis-Ord local statistic.", echo = TRUE}
plot_patches(
    # The raw temperature data
    df = flir_stats$df,
    # The patch outlines
    patches = flir_stats$patches
)
```

# References
